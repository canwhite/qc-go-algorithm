package sort

/**
堆排序的原理是利用一个最大堆或者最小堆来对一个数组进行排序。
一个最大堆是一个完全二叉树，满足每个节点的值都大于等于它的子节点的值。
一个最小堆是一个完全二叉树，满足每个节点的值都小于等于它的子节点的值。

PS-1：完全二叉树和满二叉树的区别
完全二叉树
1. 除了最后一层,其他层的节点数达到最大值。
2. 最后一层或者连续多层的叶节点在左边连续出现。
     1
   /   \
  2     3
 / \   /
4   5 6


满二叉树:
1. 所有层的节点数都达到最大值。
2. 叶节点只能出现在最后两层。
        1
     /     \
    2       3
   / \     / \
  4   5   6   7


PS-2：平衡二叉树是一种完全二叉树吗？

平衡二叉树不一定是完全二叉树，因为它可能有空缺的节点，或者最后一层的节点不是靠左排列的

    1
   / \
  2   3
 / \   \
4   5   6



堆排序的过程分为两个步骤：

建堆：将一个无序的数组调整成一个最大堆或者最小堆，这个过程可以自底向上或者自顶向下进行，时间复杂度是O(n)。
排序：每次从堆中取出堆顶元素（最大值或者最小值），放到数组的末尾，然后将剩余的元素重新调整成一个堆，
	这个过程需要重复n-1次，每次调整的时间复杂度是O(logn)，所以总的时间复杂度是O(nlogn)。
*/

func HeapSort(nums []int) {
	//分成建堆和调整排序

}

// buildMaxHeap函数将一个无序的切片调整成一个最大堆
/*****
这是一个关于堆排序的问题。堆排序是基于完全二叉树实现的，完全二叉树的性质之一是：
如果节点序号为i，在它的左孩子序号为2*i+1，右孩子序号为2*i+2。
---
因此，最后一个非叶子节点的序号就是最后一个节点的父节点的序号。
如果最后一个节点的序号是n-1（从0开始），那么它的父节点的序号就是(n-1-1)/2，也就是(n-2)/2，简化为n/2-1。
例如，如果一个节点的序号是5，那么它的左孩子的序号是2*5+1=11，右孩子的序号是2*5+2=12

序号顺序是从上到下，从左到右吗？
是的，序号是从上到下，从左到右的。也就是说，根节点的序号是0，它的左孩子的序号是1，右孩子的序号是2，以此类推。这样可以方便地用数组来存储完全二叉树的节点。


******/
