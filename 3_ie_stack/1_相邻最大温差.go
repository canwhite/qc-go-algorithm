package iestack

import "fmt"

/*
* 给一个数组，返回一个大小相同的数组。
* 对于原数组中的第 i 个元素，至少往右走多少步，才能遇到一个比自己大的元素，
* 如果之后没有比自己大的元素，或者已经是最后一个元素，则在返回数组的对应位置放上 -1。
* 输入  [5,3,1,2,4]
* 输出  [-1 3 1 1 -1]

这就需要使用单调栈了。通过单调递增栈的定义，即沉淀大数
每当遇到元素大于栈顶元素时，我们就遇到了一个"大数"。
这个"大数"比它之前多少个数大我们不知道，但是至少比当前栈顶所对应的数大。
我们弹出栈内所有对应数比这个数小的栈内元素，
并更新它们在返回数组中对应位置的值。
因为这个栈本身的单调性，当栈顶元素所对应的数比这个元素大的时候，
我们可以保证，栈内所有元素都比这个元素大。
这种方法可以理解为《沉淀大数》，
对于每一个元素，当它出栈的时候，说明它遇到了第一个比自己大的元素，
这样下来，不难理解这个思路：

for 元素 in 列表:
	while 栈不为空 and 栈顶元素 < 元素：
		x = 栈顶出栈
		对应业务处理给到结果集
	入栈
*/

// 理解这个题主要可以看输出
func DailyTemperatures(nums []int) []int {
	stack := []int{}              // 初始化空栈
	res := make([]int, len(nums)) // 结果数组
	// 初始化为-1
	for i := range res {
		res[i] = -1
	}

	for i, num := range nums {

		// 循环迭代,直到遇到当前元素大于stack栈顶的元素
		// stack里存的，相当于前置的比较大的数的下标
		// 而num相当于一个后置指针对应的值，然后这里循环去和前边指针对应的值去比较
		// 然后这道题是计算出坐标差值
		// 当前边的小于num的时候，去计算，后边找大的
		// 栈不为空，且后边出现了大值
		for len(stack) > 0 && nums[len(stack)-1] < num {
			//弹出堆顶下标，然后做相关操作，这里用的是距离，所以没用到原值
			topIndex := stack[len(stack)-1]
			fmt.Println("pop:", topIndex)
			// 求出索引间距
			res[topIndex] = i - topIndex
			// go相对java来说多了一个压缩切片的过程
			stack = stack[:len(stack)-1]
		}
		fmt.Println("push:", i)
		//这个相当于保存下标对应的值
		stack = append(stack, i)
	}
	return res
}
